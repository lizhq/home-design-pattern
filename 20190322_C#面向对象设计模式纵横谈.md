
# [C#面向对象设计模式纵横谈](https://blog.csdn.net/Jack_software/article/details/78675005)

## 面向对象设计模式与原则
* 针对接口编程，而不是针对实现编程
* 优先使用对象组合，而不是类继承
* 封装变化点
* 使用重构得到模式---设计模式的应用不宜先入为主
### 设计原则
*	单一职责原则（SRP）
*	开放封闭原则（OCP）
*	（里氏）Liskov替换原则（LSP）
*	依赖导致原则（DIP）
*	接口隔离原则（ISP）
## 23种设计模式 （1-5,6-12,13-23）
* 1.Singleton单例模式
	#### 动机（Motivation）
	在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性以及良好的效率
	如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？
	这应该是类设计者的责任，而不是使用者的责任
	### 意图（Intent）
	保证一个类仅有一个实例，并提供一个实例的全局访问点。
	### 结构（Struct）
	![Singleton Struct](https://img-blog.csdnimg.cn/20190323133353134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfc29mdHdhcmU=,size_16,color_FFFFFF,t_70 "Singleton Struct")
* 2.Abstract Factory抽象工厂模式
	#### 动机（Motivation）
	在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作
	如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列”具体对象创建工作的紧耦合？
	### 意图（Intent）
	提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们 的具体类。
	### 结构（Struct）
	![Abstract Factory](https://img-blog.csdnimg.cn/20190323135329235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfc29mdHdhcmU=,size_16,color_FFFFFF,t_70 "Abstract Factory")
* 3.Builder生成器模式
* 4.Factory Method工程方法模式
* 5.Prototype原型模式
* 6.Adapter适配器模式
* 7.Bridge桥接模式
* 8.Composite组合模式
* 9.Decorator装饰模式
* 10.Facade外观模式
* 11.Flyweight享元模式
* 12.Proxy代理模式
* 13.Template Method模板方法
* 14.Command模式
* 15.Interpreter解释器模式
* 16.Mediator中介者模式
* 17.Iterator迭代器模式
* 18.Observer观察者模式
* 19.Chain of Responsibility职责链模式
* 20.Memento备忘录模式
* 21.State状态模式
* 22.Strategy策略模式
* 23.Visitor访问者模式

# 总结 （23）

## 创建型模式 （5）
* Singleton模式解决的是实体对象个数的问题。除了Singleton之外，其他创建型模式解决的都是new所带来的耦合关系。
* Factory Method，Abstract Factory，Builder都需要一个额外的工厂类来负责实例化“易变对象”，而Prototype则是通过原型（一个特殊的工程类）来克隆“易变对象”。
* 如果遇到“易变类”，起初的设计通常从Factory Method开始，当遇到更多的复杂变化时，在考虑重构为其他三种工厂模式（Abstract Factory，Builder，Prototype）

## 结构型模式 （7）
* Adapter模式注重转换接口，将不吻合的接口适配对接
* Bridge模式注重分离接口与其实现，支持多维度的变化
* Composite模式注重统一接口，将“一对多”的关系转化为“一对一”的关系
* Decorator模式注重稳定接口，再此前提下为对象扩展功能
* Facade模式注重简化接口，简化组件系统与外部客户程序的依赖关系
* Flyweight模式注重保留接口，在内部使用共享结束对对象存储进行优化
* Proxy 模式注重假借接口，增加间接层来实现灵活控制

## 行为型模式 （11）
* Template Method模式封装算法结构，支持算法子步骤变化
* Strategy模式注重封装算法，支持算法的变化
* State模式注重封装与状态相关的行为，支持状态的变化
* Memento模式注重封装对象状态的变化，支持状态保存/恢复
* Mediator模式注重封装对象间的交互，支持对象交互的变化
* Chain of Responsibility模式注重封装对象责任，支持责任的变化
* Command模式注重将请求封装为对象，支持请求的变化
* Iterator模式注重封装集合对象内部结构，支持集合的变化
* Interpreter模式注重封装特定领域变化，支持领域问题的频繁变化
* Observer模式注重封装对象通知，支持通信对象的变化
* Visitor模式注重封装对象操作变化，支持在运行时为类层次结构动态添加新的操作
